---
title: (1/3) Linear model
author: "Umut Caglar"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# The Line Fit Function
This is a document invetigates details of linear model 


```{r install packages, echo=FALSE, warning=FALSE, results='hide',message=FALSE}

###*****************************
# INITIAL COMMANDS TO RESET THE SYSTEM
rm(list = ls())
if (is.integer(dev.list())){dev.off()}
cat("\014")
seedNo=14159
set.seed(seedNo)
###*****************************

###*****************************
require("sicegar")
require("dplyr")
require("ggplot2")
require("cowplot")
###*****************************
```

## Data generation
To simulate the results, we will go backwards and firstly generate some data to analyze. To add some randomness to the input data I will use some noise. The input of all package must be in the form of a data frame with at least 2 columns time and intensity. 

`sicegar::lineFitFormula` generate a set of intensity values based on time, slope and intersection values supplied. So here we are generating a set of points that are on a line with a slope of 4 which intersects with x axis at -2.

```{r generate data}
time=seq(3,24,0.5)

#intensity with Noise
noise_parameter=7
intensity_noise=stats::runif(n = length(time),min = 0,max = 1)*noise_parameter
intensity=sicegar::lineFitFormula(time, slope=4, intersection=-2)
intensity=intensity+intensity_noise

dataInput=data.frame(intensity=intensity,time=time)
```

## Data normalization 

This is the first step. Data should be normalized before any fit. I.e time and intensity should be in between 0-1 interval. 

There is a nuance 

*  Time is normalized with respect to maximum value the time parameter takes.
```{r time normalization, eval=FALSE}
timeRatio=max(timeData); timeData=timeData/timeRatio
```

*  Intensity is normalized with respect to intensity interval
```{r intensity normalization, eval=FALSE}
intensityMin = min(dataInput$intensity)
intensityMax = max(dataInput$intensity)
intensityRatio = intensityMax - intensityMin

intensityData=dataInput$intensity-intensityMin
intensityData=intensityData/intensityRatio
```

The normalization code is 

```{r normalize_data}
normalizedInput = normalizeData(dataInput = dataInput, 
                                dataInputName = "Sample001")
```


Components of the normalization output

```{r normalized_data_output}
head(normalizedInput$timeIntensityData) # the normalized time and intensity data
print(normalizedInput$dataScalingParameters) # the normalization parameters that is needed to go back to original scale
print(normalizedInput$dataInputName) # a useful feature to track the sample in all the process
```


## The figures of raw and normalized datasets

```{r plot raw and normal data, echo=FALSE, fig.height=4, fig.width=8}
dataInput %>% dplyr::mutate(process="raw")->dataInput2
normalizedInput$timeIntensityData %>%
  dplyr::mutate(process="normalized")->timeIntensityData2
dplyr::bind_rows(dataInput2,timeIntensityData2) -> combined
combined$process <- factor(combined$process, levels = c("raw","normalized"))

ggplot(combined,aes(x=time, y=intensity))+
  facet_wrap(~process, scales = "free")+
  geom_point()
```

## Line fit of the data

Now it is time to calculate the parameters by using `sicegar::lineFitFunction()`

```{r linefit_data}
parameterVector<-lineFitFunction(dataInput = normalizedInput, tryCounter = 2)

# Where tryCounter is a tool usually provided by sicegar::fitFunction when the sicegar::lineFitFunction is called from sicegar::fitFunction. 

# If tryCounter==1 it took the  start position given by sicegar::fitFunction
# If tryCounter!=1 it generates a random start position from given interval
```

the function outputs a vector that gives information about multiple parameters

```{r parameter vector}
print(t(parameterVector))
```

Here is the brief explanations of the parameters that are given by lineFitFunction (In different order then than the output vector of the lineFitFunction)

These are the parameters of the normalization step:

* `dataScalingParameters.timeRatio`: Maximum of raw time data       
* `dataScalingParameters.intensityMin`: Minimum of raw intensity data
* `dataScalingParameters.intensityMax`: Maximum of raw intensity data
* `dataScalingParameters.intensityRatio`: Maximum - Minimum of intensity data

They are the meta summary of the result parameters

* `model`: Gives the used model for fitting
* `isThisaFit`: FALSE means there is not any successful fit. TRUE means there is at least one successful fit 

Likelihood maximization algorithm starts from a random initiation point and goes down the fitness space by a gradient decent algorithm. these parameters represent the start point of the gradient decent algorithm.

* `startVector.slope`: Slope value of the initialtion point
* `startVector.intersection`: Intersection value of the initialtion point

For each parameter that needs to fitted by LM algorithm; the algorithm gives a bunch of statistical parameters; including the estimated value of the parameter. __Note: They are for normalized data.__


They are the parameters associated with parameter "slope"

* `slope_N_Estimate`: here N stand for the slope in the normalized scale
* `slope_Std_Error`
* `slope_t_value`    
* `slope_Pr_t`

They are the parameters associated with parameter "intersection"

* `intersection_N_Estimate`  here N stand for the intersection in the normalized scale
* `intersection_Std_Error`  
* `intersection_t_value`  
* `intersection_Pr_t` 


Here are the fit-parameters that are not related with individual variable that is fitted, but gives information about overal fit.

They are the parameters associated with the quality of the fit. 

* `residual_Sum_of_Squares`: Small value indicate better fit
* `log_likelihood`: Higher value indicate a better fit
* `AIC_value`: Smaller value indicate a better fit
* `BIC_value`: Smaller value indicate a better fit

Final results that are relavent to most of the users   

They are the fitter values after converting everything from normalized to un-normalized scale.

* `intersection_Estimate`: Intersection estimate for the raw data
* `slope_Estimate`: Slope estimate for the raw data


## Check the results to see if the results are meaningfull

By using the `intersection_Estimate`, `slope_Estimate` parameters of the linefit and the time sequence that we already created we can calculate the intensity values by the help of `sicegar::lineFitFormula()`. We can draw the bes line on top of our initial data.

```{r plot raw data and fit, fig.height=4, fig.width=8}
intensityTheoretical=lineFitFormula(time,
                                    slope=parameterVector$slope_Estimate,
                                    intersection=parameterVector$intersection_Estimate)
comparisonData=cbind(dataInput,intensityTheoretical)

ggplot(comparisonData)+
  geom_point(aes(x=time, y=intensity))+
  geom_line(aes(x=time,y=intensityTheoretical))+
  expand_limits(x = 0, y = 0)
```